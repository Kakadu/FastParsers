/**
 * Created with IntelliJ IDEA.
 * User: Eric
 * Date: 12.02.14
 * Time: 15:56
 * To change this template use File | Settings | File Templates.
 */

import scala.collection.{mutable, GenSeqLike}
import scala.collection.mutable._
import scala.language.experimental.macros
import scala.reflect.api.Universe
import scala.reflect.internal.annotations.compileTimeOnly
import scala.reflect.macros.whitebox.Context
import scala.collection.mutable.ListBuffer

object FastParsers {

  trait Parser[+T]{

    @compileTimeOnly("can’t be used outside FastParser")
    def ~[U](parser2: Parser[U]):Parser[(T,U)] =  ???
    @compileTimeOnly("can’t be used outside FastParser")
    def ~>[U](parser2: Parser[U]):Parser[U] =  ???
    @compileTimeOnly("can’t be used outside FastParser")
    def <~[U](parser2: Parser[U]):Parser[T] =  ???
    @compileTimeOnly("can’t be used outside FastParser")
    def |[U >: T](parser2: Parser[U]):Parser[U] =  ???
    @compileTimeOnly("can’t be used outside FastParser")
    def ||[U >: T](parser2: Parser[U]):Parser[U] =  ???

    //deprecated
   /* @compileTimeOnly("can’t be used outside FastParser")
    def `?`[X >: T]:Parser[List[T]] =  ???
    @compileTimeOnly("can’t be used outside FastParser")
    def `+`[X >: T]:Parser[List[T]] =  ???
    @compileTimeOnly("can’t be used outside FastParser")
    def `*`[X >: T]:Parser[List[T]] =  ???         */

    @compileTimeOnly("can’t be used outside FastParser")
    def ^^[U](f:T => U):Parser[U] = ???
    @compileTimeOnly("can’t be used outside FastParser")
    def map[U](f:T => U):Parser[U] = ???
    @compileTimeOnly("can’t be used outside FastParser")
    def ^^^[U](f:U):Parser[U] = ???

    @compileTimeOnly("can’t be used outside FastParser")
    def filter[U](f:T => Boolean):Parser[T] = ???        //(==>)   ???


    @compileTimeOnly("can’t be used outside FastParser")
    def rep[X >: T](min:Int,max:Int):Parser[T] = ???

   /* @compileTimeOnly("can’t be used outside FastParser")
    def repfold(min:Int,max:Int):Parser[T] = ???   */

   /* @compileTimeOnly("can’t be used outside FastParser")
    def repFold[U](init:U)(f:(U,T) => U):Parser[U] = ???   */

    @compileTimeOnly("can’t be used outside FastParser")
    def repFold[U](init:U,f:(U,T) => U):Parser[U] = ???

    @compileTimeOnly("can’t be used outside FastParser")
    def withFailureMessage(msg:String):Parser[T] = ???

    @compileTimeOnly("can’t be used outside FastParser")
    def unary_- :Parser[T] = ???

  }

  @compileTimeOnly("can’t be used outside FastParser")
  def rep[T](p:Parser[T],min:Int = 0,max:Int = -1):Parser[List[T]] = ???
  @compileTimeOnly("can’t be used outside FastParser")
  def rep1[T](p:Parser[T]):Parser[List[T]] = ???
  @compileTimeOnly("can’t be used outside FastParser")
  def opt[T](p:Parser[T]):Parser[List[T]] = ???

  @compileTimeOnly("can’t be used outside FastParser")
  def repsep[T](p:Parser[T],sep:Parser[T]):Parser[List[T]] = ???

  @compileTimeOnly("can’t be used outside FastParser")
  def repFold[T,U](p:Parser[T])(init:U)(f:(U,T)=> U):Parser[U] = ???


  def seq[T](elem:T):Parser[T] = ???
  //def seq[T](elem:Parser[T]*):Parser[T] = ???
  def alt[T](elem:Array[T]):Parser[T] = ???   //need a SeqLike //WAY TOO SLOW

  @compileTimeOnly("can’t be used outside FastParser")
  def range[T](a:T,b:T):Parser[T] = ???

  @compileTimeOnly("can’t be used outside FastParser")
  def phrase[T](a:Parser[T]):Parser[T] = ???

  @compileTimeOnly("can’t be used outside FastParser")
  def not[T](a:Parser[T]):Parser[T] = ???
  //unary_! TODO

  @compileTimeOnly("can’t be used outside FastParser")
  def guard[T](a:Parser[T]):Parser[T] = ???
  //& operator TODO

  @compileTimeOnly("can’t be used outside FastParser")
  def wildcard[T]:Parser[T] = ???

  @compileTimeOnly("can’t be used outside FastParser")
  def ignore[T](a:Parser[T]):Parser[T] = ???

  @compileTimeOnly("can’t be used outside FastParser")
  def call[T](a:Parser[T]):Parser[T] = ???

  @compileTimeOnly("can’t be used outside FastParser")
  def takeWhile[T](f:T => Boolean):Parser[Array[T]] = ???

  @compileTimeOnly("can’t be used outside FastParser")
  def takeWhile2[T,Input](f:T => Boolean):Parser[InputWindow[Input]] = ???

  @compileTimeOnly("can’t be used outside FastParser")
  def except[T](elems:T*):Parser[T] = ???

  implicit def toElem[T](elem:T):Elem[T] = Elem(elem)
  implicit def toElemList[T](elem:List[T]):Parser[List[T]] = ???
  case class Elem[T](elem:T) extends Parser[T]

  class InputWindow[T](val input:T,val  begin:Int,val  end:Int)


  /**
   *
   * @param success If the result is a success
   * @param msg The error message if any (only relevant if success == false)
   * @param result The result generated by the parser
   * @param inputPos The position in the input at which the parser has finished to read
   * @tparam T Type of the result
   */
  case class ParseResult[+T](success:Boolean,msg:String,result:T, inputPos:Int)

  object Success {
    def unapply[T](p:ParseResult[T]):Option[T] =
      if (p.success) Some(p.result)
      else  None
  }

  object Failure {
    def unapply[T](p:ParseResult[T]):Option[String] =
      if (!p.success) Some(p.msg)
      else  None
  }

  def FastParser(rules: => Unit):Any = macro FastParser_impl
  def FastParser_impl(c: Context)(rules: c.Tree)= {
    import c.universe._

    trait Input {
      def init:c.Tree
      def currentInput:c.Tree
      def advance:c.Tree
      def advanceTo(offset:c.Tree):c.Tree
      def mark(code:c.Tree => c.Tree):c.Tree
      def isEOI:c.Tree
      def isNEOI:c.Tree
      def pos:c.Tree
      def offset:c.Tree
      def inputType:c.Tree
      def getChunk(typ:c.Tree,code:c.Tree => c.Tree):c.Tree
    }

    object ReaderInput extends Input {
      def init = q""
      def currentInput = q"input.first"
      def advance = q"input = input.rest"
      def advanceTo(offset:c.Tree) = q"input = input.drop($offset)"

      def mark(code:c.Tree => c.Tree):c.Tree = {
        val input_tmp = TermName(c.freshName)
        q"""
          val $input_tmp = input
          ${code(q"input = $input_tmp")}
      """
      }
      def isEOI = q"input.atEnd"
      def isNEOI = q"!input.atEnd"
      def pos = q"input.offset" //.pos
      def offset = q"input.offset"
      def inputType = tq"Reader[Char]"
      def getChunk(typ:c.Tree,code:c.Tree => c.Tree) = {
        val tmp = TermName(c.freshName)
        q"""
        val $tmp = new ArrayBuffer[$typ]()
        ${code(q"$tmp.append($currentInput)")}
        $tmp
        """
      }
    }

    object StreamMarkedInput extends Input {
      def init = q""
      def currentInput = q"input.get"
      def advance = q"input.next"
      def advanceTo(offset:c.Tree) = q""
      def mark(code:c.Tree => c.Tree) = {
        val input_tmp = TermName(c.freshName)
        q"""
          val $input_tmp = input.mark
          ${code(q"input.rollBack($input_tmp)")}
      """
      }
      def isEOI = q"input.atEnd"
      def isNEOI = q"input.notAtEnd"
      def pos = q"input.offset"
      def offset = q"input.offset"
      def inputType = tq"StreamMarked[Char]"
      def getChunk(typ:c.Tree,code:c.Tree => c.Tree) = {
        val tmp = TermName(c.freshName)
        q"""
        val $tmp = new ArrayBuffer[$typ]()
        ${code(q"$tmp.append($currentInput)")}
        $tmp
        """
      }
    }

    object ArrayInput extends Input {
      def init =
        q"""
        var inputpos = 0
        val inputsize = input.size
        """
      def currentInput = q"input.charAt(inputpos)"
      def advance = q"inputpos = inputpos + 1"
      def advanceTo(offset:c.Tree) = q"inputpos += $offset"
      def mark(code:c.Tree => c.Tree) = {
        val input_tmp = TermName(c.freshName)
        q"""
          val $input_tmp = inputpos
          ${code(q"inputpos = $input_tmp")}
      """
      }
      def isEOI = q"inputpos >= inputsize"
      def isNEOI = q"inputpos < inputsize"
      def pos = q"inputpos"
      def offset = q"inputpos"
      def inputType = tq"String"
      def getChunk(typ:c.Tree,code:c.Tree => c.Tree) = {
        val beginPos = TermName(c.freshName)
        q"""
        val $beginPos = $pos
        ${code(q"")}
        if ($isEOI)
          input.substring($beginPos,$pos - 1).toCharArray
        else
          input.substring($beginPos,$pos).toCharArray
        """
      }
    }

    val input = ArrayInput

    /**
     * Define an individual result in a parser
     */
    type Result = (TermName,c.Tree,Boolean)

    type RuleType = c.Type
    type RuleCode = c.Tree
    type RuleInfo = (RuleType,RuleCode)

    /**
     * Get the "zero" value of a certain type
     * @param typ
     * @return
     */

    def zeroValue(typ:c.Tree):c.Tree = {
      def fromString(str:String) = str match {
        case "Char" => q"' '"
        case "Int" => q"0"
        case "Float" => q"0"
        case "Double" => q"0.0D"
        case "String" => q""""""""
        case x if x.startsWith("List") => q"Nil"
        case _ => q"null"
      }

      typ match {
        case Ident(TypeName(name)) => fromString(name)
        case AppliedTypeTree(Ident(TypeName("List")),_) =>  q"Nil"
        //case x:TypeTree => fromString(x.toString)
        case x => fromString(x.toString)
        //case _ => q"null"
      }
    }

    /**
     * Generate the boilerplate code and the transformed code of the rule
     * @param rule The code to be transformed
     * @return The transformed code
     */
    def parseRule(rule:c.Tree,returnType:c.Tree):c.Tree = {
      val results = new ListBuffer[Result]()
      val transform = parseRuleContent(rule,results)
      val initResults = results.map(x => q"var ${x._1}:${x._2} = ${zeroValue(x._2)}")
      val tupledResults = combineResults(results)  //lol ?

      val result = q"""ParseResult(success,msg,if (success) $tupledResults else ${zeroValue(returnType)},${input.offset})"""
      val tree = q"""
        ..$initResults
        $transform
        $result
      """
      tree
      //q"""println(show(reify($tree)))"""
    }

    /**
     * Combine a list of results into either a tuple of result or into the same result
     * @param results
     * @return
     */
     def combineResults(results:ListBuffer[Result]):c.Tree = {
      val usedResults = results.toList.filter(_._3)
      if (usedResults.size > 1)
          q"(..${usedResults.map(x => q"${x._1}")})"
      else if (usedResults.size == 1)
          q"${usedResults(0)._1}"
      else
          q"Nil"
    }


    def parseRep(a:c.Tree,typ:c.Tree,min:c.Tree,max:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val counter =  TermName(c.freshName)
      val cont = TermName(c.freshName)
      var results_tmp = new ListBuffer[Result]()
      val result = TermName(c.freshName)
      val tmp_result = TermName(c.freshName)

      //val checkMaxCounter = if (maxValue < 0) q"""if ($counter + 1 == $max) $cont = false""" else q""
      val checkMaxCounter = q"""if ($counter + 1 == $max) $cont = false"""

      val innerWhileTree = input.mark {rollback =>
        q"""
          ${parseRuleContent(a,results_tmp)}
          if (success) {
              $tmp_result.append(${combineResults(results_tmp)})
              $checkMaxCounter
          }
          else {
              success = $counter >= $min
              $cont = false
              if (!success)
                msg = "expected at least " + $min + " occurence(s) for rep('rule') at " + ${input.pos}
              else
                ${rollback}

          }
        """
      }
      //cannot display : show(reify($a).tree
      val tree = input.mark {rollback =>
        q"""
          var $counter = 0
          var $cont = true
          val $tmp_result = new ListBuffer[$typ]()
          success = $min == 0
          while($cont){
            $innerWhileTree
            $counter = $counter + 1
          }
          if (!success) {
            ${rollback}
          }
          else {
             $result = $tmp_result.toList
          }
        """
      }
      results_tmp = results_tmp.map(x => (x._1,x._2,false))
      results.append((result,tq"List[$typ]",true))
      results.appendAll(results_tmp)
      tree
    }

    def parseRepFold(a:c.Tree, init:c.Tree, f:c.Tree, typ:c.Tree,results:ListBuffer[Result]) : c.Tree = {
      val cont = TermName(c.freshName)
      val tmp_f = TermName(c.freshName)
      var results_tmp = new ListBuffer[Result]()
      val result = TermName(c.freshName)
      val last_result = TermName(c.freshName)

      //  $last_result =  $f($last_result,${combineResults(results_tmp)})
      val innerTree = input.mark { rollback =>
        q"""
          ${parseRuleContent(a,results_tmp)}
           if (success) {
            $last_result =  $tmp_f($last_result,${combineResults(results_tmp)})
           }
           else  {
            $rollback
            $cont = false
           }
        """
      }
      val tree = q"""
        var $cont = true
        var $last_result = $init
        val $tmp_f = $f
        while ($cont){
           $innerTree
        }
        $result = $last_result
        success = true
      """
      results_tmp = results_tmp.map(x => (x._1,x._2,false))
      results.append((result,typ,true))
      results.appendAll(results_tmp)
      tree
    }

    def parseRepsep(a:c.Tree,b:c.Tree,typ:c.Tree,results:ListBuffer[Result]) : c.Tree = {
      var results_tmp = new ListBuffer[Result]()
      var results_tmp2 = new ListBuffer[Result]()
      val cont = TermName(c.freshName)
      val tmp_result = TermName(c.freshName)
      val result = TermName(c.freshName)

      val innertree2 = input.mark{rollback =>
        q"""
          ${parseRuleContent(b,results_tmp2)}
           if (!success) {
            $cont = false
            $rollback
           }
        """
      }

      val innertree1 = input.mark{rollback =>
         q"""
          ${parseRuleContent(a,results_tmp)}
          if (success) {
             $tmp_result.append(${combineResults(results_tmp)})
             $innertree2
          }
          else {
            $cont = false
            $rollback
          }
         """
       }

       val tree = q"""
       var $cont = true
       val $tmp_result = new ListBuffer[Any]()
       while($cont) {
          $innertree1
       }
       $result = $tmp_result.toList
       success = true
       """
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      results.appendAll(results_tmp2.map(x => (x._1,x._2,false)))
      results.append((result,AppliedTypeTree(Ident(TypeName("List")),Ident(TypeName("Any"))::Nil),true))
      tree
    }

    def parseMap(a:c.Tree,typ:c.Tree,f:c.Tree,results:ListBuffer[Result]) : c.Tree = {
      val result = TermName(c.freshName)
      val tmp_f = TermName(c.freshName)
      val results_tmp = new ListBuffer[Result]()
      val tree = q"""
          val $tmp_f = $f
          ${parseRuleContent(a,results_tmp)}
           if (success)
             $result = $tmp_f(${combineResults(results_tmp)})
        """
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      results.append((result,typ,true))
      tree
    }

    def parseValue(a:c.Tree, value:c.Tree,typ:c.Tree,results:ListBuffer[Result]) : c.Tree = {
      val result = TermName(c.freshName)
      val results_tmp = new ListBuffer[Result]()
      val tree = q"""
          ${parseRuleContent(a,results_tmp)}
           if (success)
             $result = $value
        """
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      results.append((result,typ,true))//TODO à modifier
      tree
    }

    def parseFilter(a:c.Tree,typ:c.Tree, f:c.Tree,results:ListBuffer[Result]) : c.Tree = {
      val result = TermName(c.freshName)
      val tmp_f = TermName(c.freshName)
      val results_tmp = new ListBuffer[Result]()
      val tree = input.mark{rollback =>
        q"""
          val $tmp_f = $f
          ${parseRuleContent(a,results_tmp)}
           if (success && $tmp_f(${combineResults(results_tmp)}))
             $result = ${combineResults(results_tmp)}
           else {
            success = false
            msg = "incorrect result for 'rule' at filter('rule') at " + ${input.pos}
            ${rollback}
           }
        """
      }
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      results.append((result,typ,true))
      tree
    }


    def parseElem(a:c.Tree,d:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val result = TermName(c.freshName)
      results.append((result,Ident(TypeName(d.toString)),true))  //TODO check d.toString
      q"""
        if (${input.isNEOI} && ${input.currentInput} == $a){
          $result = $a
          ${input.advance}
          success = true
         }
         else {
            success = false
            msg = "expected '" + $a + " at " + ${input.pos}  }
          """
    }

    def parseElemSeq(a:c.Tree,typ:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val result = TermName(c.freshName)
      val tmp = TermName(c.freshName)
      val count = TermName(c.freshName)
      val size = TermName(c.freshName)
      results.append((result,typ,true))  //TODO check d.toString
      q"""
        val $tmp = $a
        val $size = $tmp.size
        var $count = 0
        while (${input.isNEOI} && $count < $size && ${input.currentInput} == $tmp($count)){
            ${input.advance}
            $count = $count + 1
        }
        if ($count == $tmp.size){
          $result = $tmp
          success = true
        }
        else {
            success = false
            msg = "expected '" + $a($count) + "', got '" + ${input.currentInput} + "' at " + ${input.pos}
        }
       """
    }

    def parseElemAlt(a:c.Tree, typ:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val result = TermName(c.freshName)
      val tmp = TermName(c.freshName)
      val size = TermName(c.freshName)
      val count = TermName(c.freshName)
      val found = TermName(c.freshName)
      results.append((result,typ,true))  //TODO check d.toString
      q"""
        val $tmp = $a
        val $size = $tmp.size
        var $found = false
        var $count = 0
        while(!$found && $count < $size) {
          if  (${input.currentInput} != $tmp($count)){
            $count = $count + 1
          }
          else {
            $found = true
            $result = ${input.currentInput}
            ${input.advance}
          }
        }
        success = $found
        if (!$found){
          msg = "expected on of " + show(reify($a).tree) + " but got '" + ${input.currentInput} + "' at " + ${input.pos}
        }
       """
    }

    def parseElemTakeWhile(f:c.Tree, typ:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val result = TermName(c.freshName)
      val tmp_f = TermName(c.freshName)
      //results.append((result,tq"Array[$typ]",true))
      results.append((result,tq"Array[$typ]",true))
      val tree = input.getChunk(typ,{ addInput:c.Tree =>
        q"""
        val $tmp_f = $f
        while(${input.isNEOI} && $tmp_f(${input.currentInput})) {
          $addInput
          ${input.advance}
        }
        success = true
       """
      })
      q"$result = $tree"
    }

    def parseElemTakeWhile2(f:c.Tree, typ:c.Tree,inputTyp:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val result = TermName(c.freshName)
      val tmp_f = TermName(c.freshName)
      val begin_pos = TermName(c.freshName)
      results.append((result,tq"InputWindow[$inputTyp]",true))
      q"""
        val $tmp_f = $f
        val $begin_pos = ${input.pos}
        while(${input.isNEOI} && $tmp_f(${input.currentInput})) {
          ${input.advance}
        }
        $result = new InputWindow(input,$begin_pos,${input.pos})
        success = true
      """
    }

    def parseElemExcept(a:List[c.Tree],typ:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val result = TermName(c.freshName)
      results.append((result,typ,true))  //TODO check d.toString
      val inIf = a.foldLeft(q"${input.currentInput} != ${a.head}")((acc,c) => q"$acc && ${input.currentInput} != ${c}")
      q"""
        if (${input.isNEOI} && $inIf){
          $result = ${input.currentInput}
          ${input.advance}
          success = true
        }
        else {
            success = false
            msg = "error in except at " + ${input.pos}
        }
      """
    }

    def parseRange(a:c.Tree,b:c.Tree,d:c.Tree,results:ListBuffer[Result]): c.Tree = {
      val result = TermName(c.freshName)
      results.append((result,Ident(TypeName(d.toString)),true))  //TODO check d.toString
      q"""
        if (${input.isNEOI} && ${input.currentInput} >= $a && ${input.currentInput} <= $b){
          $result = ${input.currentInput}
          ${input.advance}
          success = true
         }
         else {
            success = false
            msg = "expected in range ('" + $a + "', '" + $b + "')  at " + ${input.pos}  }
          """
    }

    def parseThen(a:c.Tree,b:c.Tree,results:ListBuffer[Result]): c.Tree = {
      q"""
          ${parseRuleContent(a,results)}
          if (success) {
            ${parseRuleContent(b,results)}
          }
       """
    }

    def parseThenRight(a:c.Tree,b:c.Tree,results:ListBuffer[Result]): c.Tree = {
      val results_tmp = new ListBuffer[Result]()
      val tree = q"""
          ${parseRuleContent(a,results_tmp)}
          if (success) {
            ${parseRuleContent(b,results)}
          }
       """
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      tree
    }

    def parseThenLeft(a:c.Tree,b:c.Tree,results:ListBuffer[Result]): c.Tree = {
      val results_tmp = new ListBuffer[Result]()
      val tree = q"""
          ${parseRuleContent(a,results)}
          if (success) {
            ${parseRuleContent(b,results_tmp)}
          }
       """
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      tree
    }

    def parseOr(a:c.Tree,b:c.Tree,typ:c.Tree,results:ListBuffer[Result]): c.Tree = {
      val result = TermName(c.freshName)
      var results_tmp1 = new ListBuffer[Result]()
      var results_tmp2 = new ListBuffer[Result]()
      val tree = input.mark{ rollback =>
        q"""
          ${parseRuleContent(a,results_tmp1)}
          if (!success) {
            ${rollback}
            ${parseRuleContent(b,results_tmp2)}
            if (success)
              $result = ${combineResults(results_tmp2)}
          }
          else {
            $result = ${combineResults(results_tmp1)}
          }
        """
      }
      results_tmp1 = results_tmp1.map(x => (x._1,x._2,false))
      results_tmp2 = results_tmp2.map(x => (x._1,x._2,false))
      results.append((result,Ident(TypeName("Any")),true))
      results.appendAll(results_tmp1)
      results.appendAll(results_tmp2)
      tree
    }

    def parseRuleCall(ruleCall:TermName,typ:c.Tree,results:ListBuffer[Result]): c.Tree = {
      val callResult = TermName(c.freshName)
      val result = TermName(c.freshName)

      val tree = q"""
        val $callResult = ${ruleCall}(input.substring(${input.offset}))
        success = $callResult.success
        if (success){
          ${input.advanceTo(q"$callResult.inputPos")}
          $result = $callResult.result
         }
        else
          msg = $callResult.msg
        """
      results.append((result,typ,true))
      tree
    }

    def parseCompound(a:c.Tree,typ:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val result = TermName(c.freshName)
      val results_tmp = new ListBuffer[Result]()
      val tree =
      q"""
        ${parseRuleContent(a,results_tmp)}
        $result = ${combineResults(results_tmp)}
      """
      results.append((result,typ,true))
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      tree
    }


    def parsePhrase(a:c.Tree,results:ListBuffer[Result]): c.Tree = {
      q"""
        ${parseRuleContent(a,results)}
        if (success) {
          if (!${input.isEOI}){
            success = false
            msg = "not all the input is consummed, at pos " + ${input.pos}
          }
        }
      """
    }

    def parseNot(a:c.Tree,results:ListBuffer[Result]): c.Tree = {
      var results_tmp = new ListBuffer[Result]()
      val tree =  input.mark{ rollback =>
        q"""
         ${parseRuleContent(a,results_tmp)}
         if (success) {
          success = false
          msg = "not parser expected failure at " + ${input.pos}
         }
         else {
          success = true
         }
         ${rollback}
       """
      }
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      tree
    }

    def parseGuard(a:c.Tree,results:ListBuffer[Result]): c.Tree = {
      var results_tmp = new ListBuffer[Result]()
      val tree =  input.mark{ rollback =>
        q"""
         ${parseRuleContent(a,results_tmp)}
         ${rollback}
       """
      }
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      tree
    }

    def parseWithFailureMessage(a:c.Tree,msg:c.Tree,results:ListBuffer[Result]): c.Tree = {
      q"""
       ${parseRuleContent(a,results)}
        if (!success)
           msg = $msg
      """
    }

    def parseWildcard(d:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val result = TermName(c.freshName)
      results.append((result,Ident(TypeName(d.toString)),true))  //TODO check d.toString
      q"""
        if (${input.isNEOI}){
          $result = ${input.currentInput}
          ${input.advance}
          success = true
         }
         else {
            success = false
            msg = "end of input at " + ${input.pos}  }
       """
    }


    def parseIgnore(a:c.Tree,results:ListBuffer[Result]):c.Tree = {
      val results_tmp = new ListBuffer[Result]()
      val tree = q" ${parseRuleContent(a,results_tmp)}"
      results.appendAll(results_tmp.map(x => (x._1,x._2,false)))
      tree
    }

    /**
     * Switch function which transform a parser combinator style into an imperative style
     * @param rule The code to be transformed
     * @param results The results variable name which will be generated in the transformed code
     * @return The expanded code
     */
    def parseRuleContent(rule:c.Tree,results:ListBuffer[Result]):c.Tree = rule match{
      case q"FastParsers.toElem[$d]($a)" =>
        parseElem(a,d,results)
      case q"FastParsers.toElemList[$d]($a)" =>
        parseElemSeq(a,d,results)
      case q"FastParsers.seq[$d]($a)" =>
        parseElemSeq(a,d,results)
      case q"FastParsers.alt[$d]($a)" =>
        parseElemAlt(a,d,results)
      case q"FastParsers.takeWhile[$d]($f)" =>
        parseElemTakeWhile(f,d,results)
      case q"FastParsers.takeWhile2[$d,$input]($f)" =>
        parseElemTakeWhile2(f,d,input,results)
      case q"FastParsers.range[$d]($a,$b)" =>
        parseRange(a,b,d,results)
      case q"FastParsers.except[$d](..$a)" =>
        parseElemExcept(a,d,results)
      case q"FastParsers.wildcard[$d]" =>
        parseWildcard(d,results)
      case q"$a ~[$d] $b" =>
        parseThen(a,b,results)
      case q"$a ~>[$d] $b" =>
        parseThenRight(a,b,results)
      case q"$a <~[$d] $b" =>
        parseThenLeft(a,b,results)
      case q"$a ||[$d] $b" =>
        parseOr(a,b,d,results)
      case q"$a |[$d] $b" =>
        parseOr(a,b,d,results)
      case q"$a.rep[$d]($min,$max)" =>
        parseRep(a,d,min,max,results)
      /*case q"$a.repFold[..$d]($init)($f)" =>
        parseRepFold(a,init,f,results) */
      case q"$a.repFold[$d]($init,$f)" =>
        parseRepFold(a,init,f,d,results)
      case q"FastParsers.repFold[$d]($a)($init)($f)" =>
        parseRepFold(a,init,f,d,results)
      /*case q"$a?[$d]" =>
        parseRep(a,d,q"0",q"1",results)
      case q"$a+[$d]" =>
        parseRep(a,d,q"1",q"-1",results)
      case q"$a*[$d]" =>
        parseRep(a,d,q"0",q"-1",results)*/
      case q"FastParsers.rep[$d]($a,$min,$max)" =>
        parseRep(a,d,min,max,results)
      case q"FastParsers.rep1[$d]($a)" =>
        parseRep(a,d,q"1",q"-1",results)
      case q"FastParsers.opt[$d]($a)" =>
        parseRep(a,d,q"0",q"1",results)
      case q"FastParsers.repsep[$d]($a,$b)" =>
        parseRepsep(a,b,d,results)
      case q"""call[$d](${ruleCall : TermName})""" =>
        parseRuleCall(ruleCall,d,results)
      case q"""compound[$d]($a)""" =>
        parseCompound(a,d,results)
      case q"$a map[$d] ($f)" =>
        parseMap(a,d,f,results)
      case q"$a ^^ [$d]($f)" =>
        parseMap(a,d,f,results)
      case q"$a ^^^ [$d]($f)" =>
        parseValue(a,f,d,results)
      case q"$a filter [$d]($f)" =>
        parseFilter(a,d,f,results)
      case q"FastParsers.phrase[$d]($a)" =>
        parsePhrase(a,results)
      case q"FastParsers.not[$d]($a)" =>
        parseNot(a,results)
      case q"FastParsers.guard[$d]($a)" =>
        parseGuard(a,results)
      case q"$a withFailureMessage($msg)" =>
        parseWithFailureMessage(a,msg,results)
      case q"FastParsers.ignore[$d]($a)" =>
        parseIgnore(a,results)
      case q"-$a" =>
        parseIgnore(a,results)
      case _ => q"""println(show(reify($rule)))"""
    }

    /**
     * Expand each rule in a imperative style without considering other rules (i.e def rule2 = rule1 is not expanded to the code of rule1)
     * @return An HashMap containing (rulename, corresponging code)
     */
    def getBasicStructure = {
      val rulesMap = new HashMap[String,RuleInfo]()
      rules match {
        case q"{..$body}" =>
          body.foreach (_ match {
            case q"def $name:${d:TypeTree} = $b" =>
              /*val tq"$f[$typ]" = d    */
              val x = d.tpe match {
                case TypeRef(_,_,z) => z.head//q"Any".tpe//q"var x:${d.tpe}" //check it is a parser
                case _ => c.abort(c.enclosingPosition,"incorrect parser type")
              }
              val TermName(nameString) = name
              val in = (nameString,(x, b))
              rulesMap += in
            //case q""  =>
            case q"()" =>
            case x => c.abort(c.enclosingPosition, "body must only contain rule definition with the following form : def ruleName = body : " + x)
          })
          c.Expr(q"""println(..${rulesMap.keys})""")
        case _ =>
          c.abort(c.enclosingPosition, "ill-formed body, cannot be empty")//TODO can be empty ?
      }
      rulesMap
    }

    def expandCallRule(tree:c.Tree,rulesMap: HashMap[String,RuleInfo],rulesPath:List[String]):c.Tree = tree match {
      case q"$a.$m[..$d](..$b)" =>
        val callee = expandCallRule(a,rulesMap,rulesPath)
        val args = b.map(expandCallRule(_,rulesMap,rulesPath))
        q"$callee.$m[..$d](..$args)"
      case q"$f[..$d](..$b)" =>
        val callee = expandCallRule(f,rulesMap,rulesPath)  //because of repFold and al curried stuff
        val args = b.map(expandCallRule(_,rulesMap,rulesPath))
        q"$callee[..$d](..$args)"
      case q"$a.${f:TermName}" =>
        val callee = expandCallRule(a,rulesMap,rulesPath)
        q"$callee.$f"
      case q"${ruleCall : TermName}" =>
        val name = ruleCall.toString
        if (rulesMap.keySet.contains(name)){
          if(!rulesPath.contains(name))
            q"compound[${rulesMap(name)._1}](${expandCallRule(rulesMap(name)._2,rulesMap,name::rulesPath)})"
          else
            q"call[${rulesMap(name)._1}]($tree)"
        }
        else
          tree
      case _ => tree
    }

    def expandRules(rulesMap: HashMap[String,RuleInfo]) = {
      val expandedRulesMap = new HashMap[String,RuleInfo]()
      for (k <- rulesMap.keys)  {
        val ruleCode = rulesMap(k)._2
        val ruleType = rulesMap(k)._1
        val rule = expandCallRule(ruleCode,rulesMap,List(k))
        expandedRulesMap += ((k,(ruleType,parseRule(rule,tq"$ruleType"))))
      }
      expandedRulesMap
    }

    def replaceInRules(rulesMap : HashMap[String,RuleInfo]) = {
      val map = new HashMap[String,RuleCode]()
      for (k <- rulesMap.keys)  {
        val term = TermName(k)
        /*

        var inputpos = 0
        val inputsize = input.size
        val input = i
        val input = i

         */
        val ruleCode = q"""
        var success = false
        var msg = ""

        var inputpos = 0
        val inputsize = input.size

        try {
          ${rulesMap(k)._2}
        } catch {
          case e:Throwable => ParseResult(false,"Exception : " + e.getMessage,${zeroValue(tq"${rulesMap(k)._1}")},${input.pos})
        }
        """
        //map += ((k,q"def $term(i:Reader[Char]) = println(show(reify($ruleCode)))"))
        map += ((k,q"def $term(input:${input.inputType}):ParseResult[${rulesMap(k)._1}] = $ruleCode"))
        //map += ((k,q"""def $term(i:${input.inputType}) = println(show(reify(${ruleCode}).tree))"""))
      }
      map
    }

    /**
     *
     * @param map Contain the rules name and their corresponding code
     * @return An AnyRef class containing where all rules are transformed in their expanded form
     */
    def createFastParser(map : HashMap[String,RuleCode]) = {
      val anon = TypeName(c.freshName)
      val dmmy = TermName(c.freshName)//no joke : see http://stackoverflow.com/questions/14370842/getting-a-structural-type-with-an-anonymous-classs-methods-from-a-macro


      val methods = map.values
      //create the final parser object which will be used
      q"""
        class $anon {
            import scala.collection.mutable.ListBuffer
            import scala.reflect.runtime.universe._
           ..$methods
        }
        val $dmmy = 0
        new $anon
      """
    }

    val rulesMap = getBasicStructure
    val expandedMap = expandRules(rulesMap)
    val finalRulesMap = replaceInRules(expandedMap)
    val tree = createFastParser(finalRulesMap)
    c.Expr(tree)
  }
}
